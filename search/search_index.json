{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Overview Docker2go is an app for Android devices which allows you to manage your Docker Host on the go. The application (of course) does not cover the full functionality of Docker. Feel free to contribute. More in section Contributing Screenshots Concept Docker2go leverages Dockers unix socket to talk to it's JSON API. The application connects through a SSH tunnel to the remote Host. The SSH tunnel is created with the third party library JSch. Then, the app does execute a curl command over the CLI. Docker2go uses Dockers HTTP API which is based on JSON. The output of the API (JSON formatted) is then parsed using Googles gson Library to use it as Java objects. This concept diagram gives an idea how the application works. Features The app currently provides the following funcionalities: Connections are displayed when Docker2go is started. It diplays all saved connection as Cards which includes operating system's logo as profile picture Add connection to a remote host Edit a connection Delete a connection Basic information is showed when a connection to a remote host is initiated Connecting to a remote host does perform a static host key check. Operating System Server version (Docker daemon version) Memory and CPU Overview of running and stopped containers (pie chart) Swarm mode (if enabled) Containers are printed out in a list where the following information gets displayed Name Status (running/stopped/exit code) Created time Image (gets showed on click) Port mappings By clicking on a container actions depending on container state may be taken Inspect Restart (if running) Start (if stopped/paused) Stop (if running) Remove Inspecting a container gives more detailed information about the desired container. Images are printed out in a list where the following information gets displayed Name Tag with shortened SHA Created time Size Actions Pull Image Prune Images Third party libraries Docker2go uses several third party libraries. Every used library is listed below with notes about the specific use case. Library Name Version License Use case JSch 0.1.54 BSD-style Used to create secure tunnel to the remote Docker host. SugarORM 1.4 MIT Used to store connection data (Hostname, User, Port, ...) Gson 2.8.0 Apache-2.0 Used to parse JSON calls to Java Objects MPAndroidChart 2.2.4 Apache-2.0 Used to draw charts (running/stopped container chart) Contributing If you find a bug, have a question want a feature, etc. drop an issue in the project issue tracker . Of course you may also submit a pull request which already fixes a bug or adds a feature. Just make sure it is well tested and maybe also documented. For this, use GitHubs fork mechanism.","title":"Overview"},{"location":"#overview","text":"Docker2go is an app for Android devices which allows you to manage your Docker Host on the go. The application (of course) does not cover the full functionality of Docker. Feel free to contribute. More in section Contributing","title":"Overview"},{"location":"#screenshots","text":"","title":"Screenshots"},{"location":"#concept","text":"Docker2go leverages Dockers unix socket to talk to it's JSON API. The application connects through a SSH tunnel to the remote Host. The SSH tunnel is created with the third party library JSch. Then, the app does execute a curl command over the CLI. Docker2go uses Dockers HTTP API which is based on JSON. The output of the API (JSON formatted) is then parsed using Googles gson Library to use it as Java objects. This concept diagram gives an idea how the application works.","title":"Concept"},{"location":"#features","text":"The app currently provides the following funcionalities: Connections are displayed when Docker2go is started. It diplays all saved connection as Cards which includes operating system's logo as profile picture Add connection to a remote host Edit a connection Delete a connection Basic information is showed when a connection to a remote host is initiated Connecting to a remote host does perform a static host key check. Operating System Server version (Docker daemon version) Memory and CPU Overview of running and stopped containers (pie chart) Swarm mode (if enabled) Containers are printed out in a list where the following information gets displayed Name Status (running/stopped/exit code) Created time Image (gets showed on click) Port mappings By clicking on a container actions depending on container state may be taken Inspect Restart (if running) Start (if stopped/paused) Stop (if running) Remove Inspecting a container gives more detailed information about the desired container. Images are printed out in a list where the following information gets displayed Name Tag with shortened SHA Created time Size Actions Pull Image Prune Images","title":"Features"},{"location":"#third-party-libraries","text":"Docker2go uses several third party libraries. Every used library is listed below with notes about the specific use case. Library Name Version License Use case JSch 0.1.54 BSD-style Used to create secure tunnel to the remote Docker host. SugarORM 1.4 MIT Used to store connection data (Hostname, User, Port, ...) Gson 2.8.0 Apache-2.0 Used to parse JSON calls to Java Objects MPAndroidChart 2.2.4 Apache-2.0 Used to draw charts (running/stopped container chart)","title":"Third party libraries"},{"location":"#contributing","text":"If you find a bug, have a question want a feature, etc. drop an issue in the project issue tracker . Of course you may also submit a pull request which already fixes a bug or adds a feature. Just make sure it is well tested and maybe also documented. For this, use GitHubs fork mechanism.","title":"Contributing"},{"location":"installation/","text":"Installation If you want to just use the app you may be better of by just installing by APK. If you want to debug or develop the app you have to install it via Source code. TL;DR: Latest version availalbe for download Prerequisites Device with Android 5.1 Lollipop or newer (API level 22) Host with Docker daemon installed A user with SSH access on this host and enough rights to access Docker's unix socket /var/run/docker.sock . This is granted by adding the user to the group docker (or using root, but is not recommended) From APK Right now, the app is only available by downloading the APK from the GitHub release section. It is unclear if the app is ever published in Google's Playstore. Make sure you permit the installation of non-official Android application by enabling Unknown sources in the security settings. The latest stable release is found on GitHub . From Source The app may also be installed from source. For this you have to install Android Studio on your laptop or PC. Download the code either via zip or tar from GitHubs webpage or as git clone. We will be using Git here. git clone https://github.com/davidkroell/docker2go.git Open up the directory in Android Studio and deploy the app onto your mobile. This will also work in an Android emulator (for developers).","title":"Installation"},{"location":"installation/#installation","text":"If you want to just use the app you may be better of by just installing by APK. If you want to debug or develop the app you have to install it via Source code. TL;DR: Latest version availalbe for download","title":"Installation"},{"location":"installation/#prerequisites","text":"Device with Android 5.1 Lollipop or newer (API level 22) Host with Docker daemon installed A user with SSH access on this host and enough rights to access Docker's unix socket /var/run/docker.sock . This is granted by adding the user to the group docker (or using root, but is not recommended)","title":"Prerequisites"},{"location":"installation/#from-apk","text":"Right now, the app is only available by downloading the APK from the GitHub release section. It is unclear if the app is ever published in Google's Playstore. Make sure you permit the installation of non-official Android application by enabling Unknown sources in the security settings. The latest stable release is found on GitHub .","title":"From APK"},{"location":"installation/#from-source","text":"The app may also be installed from source. For this you have to install Android Studio on your laptop or PC. Download the code either via zip or tar from GitHubs webpage or as git clone. We will be using Git here. git clone https://github.com/davidkroell/docker2go.git Open up the directory in Android Studio and deploy the app onto your mobile. This will also work in an Android emulator (for developers).","title":"From Source"},{"location":"under-the-hood/","text":"Under the hood This chapter will give you a brief overview about the technical aspects of the Docker2go app. The code snippets should help you to understand the concepts. Layout The layout is implemented as a card layout and most of the time leverages a ListView to display entries. The ListView in ConnectionActivity is served from a local SQLite Database accessed by SugarORM. On connecting, a new Activity gets displayed which is based on a TabbedActvity . The three Tabs (Information, Containers, Images) are implemented as Fragments . In those fragments are different layouts implemented. But they all share the SwipeToRefresh paradigm which should help to make Docker2go more usable. Additionally, on the containers Tab ( TabContainers ) a BottomSheet gets displayed by clicking on a ListViewItem. This BottomSheet gives you some basic actions based on the containers state and shows more details information. For example the Docker Image is displayed in the BottomSheet whereas its not visible in the ListView. The activity parent ( OverviewActivity ) of the Fragments holds the Connection object in order to call the remote Docker API. Multithreading Every netowork based operation is done concurrently inside a AsyncTask in order to not freeze the userinterface on long lasting operations. The Connection class provides the method executeCommand() which lets you execute one or more command on a remote host. For executing command on remote hosts the AsyncTaskCommandExecutor class is used. Every call to executeCommand() is encapsulated in a single JSch connection. @Override protected void onPreExecute () { // establish a secure connection to remote host } This class is able to execute one or more commands which must implement the Command interface. @Override protected CommandExecutionSummary doInBackground ( Command ... commands ) { try { // connect to remote host this . jschSession . connect (); // Execute single command and use onProgressUpdate for output for ( Command command : commands ) { Command c = execCommand ( command ); this . ces . addCommand ( c ); // calls method onProgressUpdate // which then call onCommandFinished publishProgress ( c ); } return this . ces ; } catch ( Exception e ) { e . printStackTrace (); // exceptions in CommandExecutionSummary can be retrieved in GUI classes this . ces . addException ( e ); return this . ces ; } finally { // make sure to close the connection this . jschSession . disconnect (); } } Docker2go leverages a listener pattern as seen in the above example. The listener class is a parameter of executeCommand() which will then call the methods onCommandFinished() or onAllCommandsFinished() depending of the state of the AsyncTask. The results of the Commands are part of the Command itself which is returned by the onCommandFinished() method. Command and Docker objects paradigm Docker2go depends highly on the use of interfaces. The Command is one of those abstract interfaces. The Command interface is implemented by DockerCommandBuilder which lets you build your command by utilizing a fluent API. DockerCommandBuilder command = new DockerCommandBuilder () . apiEndpoint ( /containers/json ) . queryParam ( all , true ) . requestMethod ( GET ); parentActivity . activeConnection . executeCommand ( this , command ); The this in the code snippet above is the listener class described in seciton Multithreading . Special in Docker2go's implementation is, that the GUI classes never talk directly to the AsyncTask in the background. Every operation is cooridinated by the Connection class. The results of the command are stored as string and can be accessed by calling the getResult() method of the Command . The results are in JSON format which gets parsed by one of DockerObjParser static methods. DockerObjParser utilizes the Gson library to make the parsing process more convinient. @Override public void onCommandFinished ( Command command ) { if ( command . exitedAsExpected ()) { DockerContainer [] dContainers = DockerObjParser . Containers ( command . getResult ()); containers . clear (); containers . addAll ( Arrays . asList ( dContainers )); containerArrayAdapter . notifyDataSetChanged (); } } The example above shows how the list of containers is refreshed by overriding the onCommandFinished() method.","title":"Under the hood"},{"location":"under-the-hood/#under-the-hood","text":"This chapter will give you a brief overview about the technical aspects of the Docker2go app. The code snippets should help you to understand the concepts.","title":"Under the hood"},{"location":"under-the-hood/#layout","text":"The layout is implemented as a card layout and most of the time leverages a ListView to display entries. The ListView in ConnectionActivity is served from a local SQLite Database accessed by SugarORM. On connecting, a new Activity gets displayed which is based on a TabbedActvity . The three Tabs (Information, Containers, Images) are implemented as Fragments . In those fragments are different layouts implemented. But they all share the SwipeToRefresh paradigm which should help to make Docker2go more usable. Additionally, on the containers Tab ( TabContainers ) a BottomSheet gets displayed by clicking on a ListViewItem. This BottomSheet gives you some basic actions based on the containers state and shows more details information. For example the Docker Image is displayed in the BottomSheet whereas its not visible in the ListView. The activity parent ( OverviewActivity ) of the Fragments holds the Connection object in order to call the remote Docker API.","title":"Layout"},{"location":"under-the-hood/#multithreading","text":"Every netowork based operation is done concurrently inside a AsyncTask in order to not freeze the userinterface on long lasting operations. The Connection class provides the method executeCommand() which lets you execute one or more command on a remote host. For executing command on remote hosts the AsyncTaskCommandExecutor class is used. Every call to executeCommand() is encapsulated in a single JSch connection. @Override protected void onPreExecute () { // establish a secure connection to remote host } This class is able to execute one or more commands which must implement the Command interface. @Override protected CommandExecutionSummary doInBackground ( Command ... commands ) { try { // connect to remote host this . jschSession . connect (); // Execute single command and use onProgressUpdate for output for ( Command command : commands ) { Command c = execCommand ( command ); this . ces . addCommand ( c ); // calls method onProgressUpdate // which then call onCommandFinished publishProgress ( c ); } return this . ces ; } catch ( Exception e ) { e . printStackTrace (); // exceptions in CommandExecutionSummary can be retrieved in GUI classes this . ces . addException ( e ); return this . ces ; } finally { // make sure to close the connection this . jschSession . disconnect (); } } Docker2go leverages a listener pattern as seen in the above example. The listener class is a parameter of executeCommand() which will then call the methods onCommandFinished() or onAllCommandsFinished() depending of the state of the AsyncTask. The results of the Commands are part of the Command itself which is returned by the onCommandFinished() method.","title":"Multithreading"},{"location":"under-the-hood/#command-and-docker-objects-paradigm","text":"Docker2go depends highly on the use of interfaces. The Command is one of those abstract interfaces. The Command interface is implemented by DockerCommandBuilder which lets you build your command by utilizing a fluent API. DockerCommandBuilder command = new DockerCommandBuilder () . apiEndpoint ( /containers/json ) . queryParam ( all , true ) . requestMethod ( GET ); parentActivity . activeConnection . executeCommand ( this , command ); The this in the code snippet above is the listener class described in seciton Multithreading . Special in Docker2go's implementation is, that the GUI classes never talk directly to the AsyncTask in the background. Every operation is cooridinated by the Connection class. The results of the command are stored as string and can be accessed by calling the getResult() method of the Command . The results are in JSON format which gets parsed by one of DockerObjParser static methods. DockerObjParser utilizes the Gson library to make the parsing process more convinient. @Override public void onCommandFinished ( Command command ) { if ( command . exitedAsExpected ()) { DockerContainer [] dContainers = DockerObjParser . Containers ( command . getResult ()); containers . clear (); containers . addAll ( Arrays . asList ( dContainers )); containerArrayAdapter . notifyDataSetChanged (); } } The example above shows how the list of containers is refreshed by overriding the onCommandFinished() method.","title":"Command and Docker objects paradigm"}]}